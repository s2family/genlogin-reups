"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }// src/index.ts
require('reflect-metadata');
var _electron = require('electron');

// src/constants.ts
var PARAMTYPES_METADATA = "design:paramtypes";
var INJECTABLE = "injectable";
var INJECT_NAME = "inject:name";
var INJECT_TYPE = {
  CLASS: "class",
  CUSTOM: "custom",
  WINDOW: "window"
};
var IPC_HANDLE = "ipc:handle";
var IPC_SEND = "ipc:send";
var IPC_ON = "ipc:on";
var IPC_WIN_NAME = "ipc:win-name";
var DEFAULT_WIN_NAME = "main";

// src/log.ts
var _colorette = require('colorette'); var colors = _interopRequireWildcard(_colorette);
var colorize = (type, data) => {
  const color = type === "info" ? "blue" : type === "error" ? "red" : type === "warn" ? "yellow" : "green";
  return colors[color](data);
};
var makeLabel = (name, type) => {
  return `${colors.dim("[")}${type ? colorize(type, name) : name}${colors.dim("]")}`;
};
var createLogger = (name = "Einf") => {
  return {
    success(...args) {
      return this.print("success", ...args);
    },
    info(...args) {
      return this.print("info", ...args);
    },
    error(...args) {
      return this.print("error", ...args);
    },
    warn(...args) {
      return this.print("warn", ...args);
    },
    log(...args) {
      console.log(name && makeLabel(name), ...args);
    },
    break() {
      console.log("\n");
    },
    print(type, ...data) {
      switch (type) {
        case "error": {
          return console.error(
            name && makeLabel(name, type),
            ...data.map((item) => colorize(type, item))
          );
        }
        default:
          console.log(
            name && makeLabel(name, type),
            ...data.map((item) => colorize(type, item))
          );
      }
    }
  };
};

// src/decorators.ts
function IpcHandle(channel) {
  if (!channel)
    throw new Error("ipc handle channel is required");
  return (target, propertyName) => {
    Reflect.defineMetadata(IPC_HANDLE, channel, target, propertyName);
  };
}
function IpcOn(channel) {
  if (!channel)
    throw new Error("ipc on channel is required");
  return (target, propertyName) => {
    Reflect.defineMetadata(IPC_ON, channel, target, propertyName);
  };
}
function IpcSend(channel, windowName = DEFAULT_WIN_NAME) {
  if (!channel)
    throw new Error("ipc send channel is required");
  return (target, propertyName) => {
    Reflect.defineMetadata(IPC_SEND, channel, target, propertyName);
    Reflect.defineMetadata(IPC_WIN_NAME, windowName, target, propertyName);
  };
}
function Controller() {
  return (_) => {
  };
}
function Injectable() {
  return (target) => {
    Reflect.defineMetadata(INJECTABLE, INJECT_TYPE.CLASS, target);
  };
}
function Inject(name) {
  if (!name)
    throw new Error("inject name is required");
  return (target, _, index) => {
    const param = Reflect.getMetadata(PARAMTYPES_METADATA, target)[index];
    Reflect.defineMetadata(INJECTABLE, INJECT_TYPE.CUSTOM, param);
    Reflect.defineMetadata(INJECT_NAME, name, param);
  };
}
function Window(name = DEFAULT_WIN_NAME) {
  return (target, _, index) => {
    const param = Reflect.getMetadata(PARAMTYPES_METADATA, target)[index];
    Reflect.defineMetadata(INJECTABLE, INJECT_TYPE.WINDOW, param);
    Reflect.defineMetadata(INJECT_NAME, name, param);
  };
}

// src/index.ts
async function createEinf({ window, controllers, injects = [] }) {
  await _electron.app.whenReady();
  const logger = createLogger();
  let windows = [];
  if (Array.isArray(window)) {
    for (const win of window)
      windows.push(typeof win === "function" ? await win() : win);
  } else {
    windows = [typeof window === "function" ? { name: DEFAULT_WIN_NAME, win: await window() } : { name: DEFAULT_WIN_NAME, win: window }];
  }
  const existInjectableClass = {};
  function factory(constructClass) {
    const paramtypes = Reflect.getMetadata(PARAMTYPES_METADATA, constructClass);
    let providers = [];
    if (paramtypes) {
      providers = paramtypes.map((provider, index) => {
        const injectType = Reflect.getMetadata(INJECTABLE, provider);
        if (injectType === INJECT_TYPE.CLASS) {
          const { name } = provider;
          const item = existInjectableClass[name] || factory(provider);
          existInjectableClass[name] = item;
          return item;
        } else if (injectType === INJECT_TYPE.CUSTOM) {
          const name = Reflect.getMetadata(INJECT_NAME, provider);
          const injectInfo = injects.find((item) => item.name === name);
          if (!injectInfo)
            throw new Error(`${name} is not provided to inject`);
          return injectInfo.inject;
        } else if (injectType === INJECT_TYPE.WINDOW) {
          const name = Reflect.getMetadata(INJECT_NAME, provider);
          const winOpt = windows.find((item) => item.name === name);
          if (!winOpt)
            throw new Error(`${name} is not provided to inject`);
          return winOpt.win;
        } else {
          throw new Error(`${constructClass.name}'s parameter [${index}] is not injectable`);
        }
      });
    }
    return new constructClass(...providers);
  }
  for (const ControllerClass of controllers) {
    const controller = factory(ControllerClass);
    const proto = ControllerClass.prototype;
    const funcs = Object.getOwnPropertyNames(proto).filter(
      (item) => typeof controller[item] === "function" && item !== "constructor"
    );
    funcs.forEach((funcName) => {
      if (Reflect.getMetadata(IPC_HANDLE, proto, funcName)) {
        const channel = Reflect.getMetadata(IPC_HANDLE, proto, funcName);
        _electron.ipcMain.handle(channel, async (e, ...args) => {
          try {
            const result = await controller[funcName].apply(controller, [...args, e]);
            return {
              data: result
            };
          } catch (error) {
            logger.error(error);
            return {
              data: void 0,
              error
            };
          }
        });
      } else if (Reflect.getMetadata(IPC_ON, proto, funcName)) {
        const channel = Reflect.getMetadata(IPC_ON, proto, funcName);
        _electron.ipcMain.on(channel, async (e, ...args) => {
          try {
            await controller[funcName].apply(controller, [...args, e]);
          } catch (error) {
            logger.error(error);
          }
        });
      } else if (Reflect.getMetadata(IPC_SEND, proto, funcName)) {
        const channel = Reflect.getMetadata(IPC_SEND, proto, funcName);
        const winName = Reflect.getMetadata(IPC_WIN_NAME, proto, funcName);
        const winInfo = windows.find((item) => item.name === winName);
        if (winInfo) {
          const { webContents } = winInfo.win;
          const func = controller[funcName];
          controller[funcName] = async (...args) => {
            const result = await func.apply(controller, args);
            webContents.send(channel, result);
            return result;
          };
        } else {
          logger.warn(`Can not find window [${winName}] to send data through [${channel}]`);
        }
      }
    });
  }
}










exports.Controller = Controller; exports.Inject = Inject; exports.Injectable = Injectable; exports.IpcHandle = IpcHandle; exports.IpcOn = IpcOn; exports.IpcSend = IpcSend; exports.Window = Window; exports.createEinf = createEinf; exports.createLogger = createLogger;
